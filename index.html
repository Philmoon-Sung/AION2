<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AION - Admin Panel (Firebase Modular SDK)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <script type="module">
      // Firebase SDK 모듈 가져오기
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-app.js";
      import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-analytics.js";
      import { 
        getAuth, 
        onAuthStateChanged, 
        signInWithEmailAndPassword, 
        signOut 
      } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-auth.js";
      import { 
        getFirestore, 
        collection, 
        addDoc, 
        doc, 
        getDoc, // getDoc 추가
        getDocs, // getDocs 추가
        setDoc, // setDoc 추가
        updateDoc, 
        deleteDoc, 
        onSnapshot, 
        query, 
        orderBy, 
        serverTimestamp, 
        arrayUnion, 
        arrayRemove,
        increment // increment 추가
      } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-firestore.js";
      import { 
        getFunctions, 
        httpsCallable 
      } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-functions.js";

      // Firebase 구성 객체 (사용자님의 실제 값으로 채워져야 합니다)
      const firebaseConfig = {
        apiKey: "AIzaSyCAfrCXrHfYWUrvZ-SKqocCXu5QNCbFRH8", // 제공해주신 값
        authDomain: "aion-18c27.firebaseapp.com",       // 제공해주신 값
        projectId: "aion-18c27",                      // 제공해주신 값
        storageBucket: "aion-18c27.appspot.com",      // 일반적인 형식으로 수정 (필요시 Firebase 콘솔에서 확인)
        messagingSenderId: "496946227122",            // 제공해주신 값
        appId: "1:496946227122:web:3c7efdd7d014743f3126ab", // 제공해주신 값
        measurementId: "G-K2F99M91CM"                 // 제공해주신 값
      };

      // Firebase 앱 초기화
      const app = initializeApp(firebaseConfig);
      const analytics = getAnalytics(app); 
      const db = getFirestore(app);
      const authInstance = getAuth(app); 
      const functionsInstance = getFunctions(app); 

      // --- 전역 변수 ---
        let currentUser = null; 
        let isAdmin = false;    
        let allContentData = []; 
        let userLikedItemsMap = new Map();
        let userPlaylists = []; 
        let userSubscribedArtistsSet = new Set(); 
        let contentListenerUnsubscribe = null; 
        let loginProcessing = false;

        // --- UI 요소 가져오기 ---
        const loginFormContainer = document.getElementById('loginFormContainer');
        const loginForm = document.getElementById('loginForm');
        const loginErrorText = document.getElementById('loginError');
        const loginSubmitButton = document.getElementById('loginSubmitButton');
        const logoutButton = document.getElementById('logoutButton');
        const logoutButtonMobile = document.getElementById('logoutButtonMobile');
        const userAvatar = document.getElementById('userAvatar');
        const profileLinkText = document.getElementById('profileLinkText');
        const profileLinkTextMobile = document.getElementById('profileLinkTextMobile');
        const newUploadsContainer = document.getElementById('newUploadsContainer');
        const newUploadsPlaceholder = document.getElementById('newUploadsPlaceholder');
        const aionChartContainer = document.getElementById('aionChartContainer');
        const aionChartPlaceholder = document.getElementById('aionChartPlaceholder');
        const recommendedMusicContainer = document.getElementById('recommendedMusicContainer');
        const recommendedMusicPlaceholder = document.getElementById('recommendedMusicPlaceholder');
        const myPlaylistsContainer = document.getElementById('myPlaylistsContainer');
        const myPlaylistsPlaceholder = document.getElementById('myPlaylistsPlaceholder');
        const subscribedArtistsContainer = document.getElementById('subscribedArtistsContainer');
        const subscribedArtistsPlaceholder = document.getElementById('subscribedArtistsPlaceholder');
        const likedSongsContainer = document.getElementById('likedSongsContainer'); 
        const likedSongsPlaceholder = document.getElementById('likedSongsPlaceholder');
        const contentSections = document.querySelectorAll('.content-section');
        const desktopSidebar = document.getElementById('desktopSidebar');
        const mobileSidebar = document.getElementById('mobileSidebar');
        const mobileSidebarOverlay = document.getElementById('mobileSidebarOverlay');
        const mobileMenuButton = document.getElementById('mobileMenuButton');
        const closeMobileSidebarButton = document.getElementById('closeMobileSidebarButton');
        const uploadFormElement = document.getElementById('uploadForm'); 
        const uploadYoutubeLinkInput = document.getElementById('uploadYoutubeLink'); 
        const uploadThumbnailPreview = document.getElementById('uploadThumbnailPreview'); 
        const youtubeModal = document.getElementById('youtubeModal');
        const closeYoutubeModalButton = document.getElementById('closeYoutubeModalButton');
        const youtubePlayer = document.getElementById('youtubePlayer');
        const editItemModal = document.getElementById('editItemModal');
        const editItemForm = document.getElementById('editItemForm');
        const cancelEditItemButton = document.getElementById('cancelEditItem');
        const editThumbnailPreview = document.getElementById('editThumbnailPreview');
        const editYoutubeLinkInput = document.getElementById('editYoutubeLink');
        const createPlaylistButton = document.getElementById('createPlaylistButton');
        const createPlaylistModal = document.getElementById('createPlaylistModal');
        const cancelCreatePlaylist = document.getElementById('cancelCreatePlaylist');
        const confirmCreatePlaylist = document.getElementById('confirmCreatePlaylist');
        const newPlaylistNameInput = document.getElementById('newPlaylistName');
        const addToPlaylistModal = document.getElementById('addToPlaylistModal');
        const playlistSelectionContainer = document.getElementById('playlistSelectionContainer');
        const playlistSelectionPlaceholder = document.getElementById('playlistSelectionPlaceholder');
        const newPlaylistNameInAddModalInput = document.getElementById('newPlaylistNameInAddModal');
        const cancelAddToPlaylist = document.getElementById('cancelAddToPlaylist');
        const confirmAddToPlaylist = document.getElementById('confirmAddToPlaylist');
        const playlistDetailModal = document.getElementById('playlistDetailModal');
        const playlistDetailNameElement = document.getElementById('playlistDetailName');
        const playlistDetailItemsContainer = document.getElementById('playlistDetailItemsContainer');
        const playlistDetailPlaceholder = document.getElementById('playlistDetailPlaceholder');
        const closePlaylistDetailModalButton = document.getElementById('closePlaylistDetailModal');
        const deletePlaylistButton = document.getElementById('deletePlaylistButton');
        const exportBtnSidebar = document.getElementById('exportContentButtonSidebar');
        const exportBtnMobileSidebar = document.getElementById('exportContentButtonMobileSidebar');
        const toastMessageElement = document.getElementById('toastMessage');
        const uploadContentTypeSelect = document.getElementById('uploadContentType');
        const youtubeLinkGroup = document.getElementById('youtubeLinkGroup');
        let currentItemToAddToPlaylist = null; 
        let currentEditingItemId = null; 

        // --- 유틸리티 함수 ---
        function getYouTubeId(url) {
            if (!url) return '';
            let videoId = '';
            const regExps = [
                /^.*(?:(?:youtu\.be\/|v\/|vi\/|u\/\w\/|embed\/|shorts\/)|(?:(?:watch)?\?v(?:i)?=|\&v(?:i)?=))([^#\&\?]{11}).*/
            ];
            for (const regExp of regExps) {
                const match = url.match(regExp);
                if (match && match[1] && match[1].length === 11) {
                    videoId = match[1];
                    break;
                }
            }
            return videoId;
        }
        function getYouTubeThumbnailUrl(videoId) {
            return videoId ? `https://i.ytimg.com/vi/${videoId}/hqdefault.jpg` : defaultThumbnail;
        }
        const defaultThumbnail = 'https://placehold.co/320x180/1A0933/4A2270?text=썸네일+미리보기';
        const thumbnailErrorPlaceholder = 'https://placehold.co/300x180/330033/FFFFFF?text=썸네일+오류';

        function showToast(message) {
            if (!toastMessageElement) return;
            toastMessageElement.textContent = message;
            toastMessageElement.classList.add('show');
            setTimeout(() => {
                toastMessageElement.classList.remove('show');
            }, 3000);
        }
        
        // --- 네비게이션 및 기본 UI 로직 ---
        const activeNavClass = 'neon-accent-bg';
        const inactiveNavClass = 'hover:bg-purple-700/30';
        
        function switchSection(sectionId) {
            contentSections.forEach(section => section.classList.remove('active'));
            const targetSection = document.getElementById(sectionId);
            if (targetSection) targetSection.classList.add('active');

            document.querySelectorAll('#desktopSidebar .nav-item, #mobileSidebar .nav-item').forEach(nav => {
                nav.classList.remove(activeNavClass);
                nav.classList.add(inactiveNavClass);
                if (nav.dataset.section === sectionId) {
                    nav.classList.add(activeNavClass);
                    nav.classList.remove(inactiveNavClass);
                }
            });
        }
        
        function openMobileSidebar() {
            if (mobileSidebar && mobileSidebarOverlay) {
                mobileSidebar.classList.remove('-translate-x-full');
                mobileSidebarOverlay.classList.remove('hidden');
            }
        }

        function closeMobileSidebar() {
            if (mobileSidebar && mobileSidebarOverlay) {
                mobileSidebar.classList.add('-translate-x-full');
                mobileSidebarOverlay.classList.add('hidden');
            }
        }
        
        // --- UI 업데이트 함수 ---
        function updateUIAfterLogin() {
            if (!currentUser || !logoutButton || !logoutButtonMobile || !profileLinkText || !profileLinkTextMobile || !userAvatar) return;
            console.log("Updating UI for logged-in user.");

            logoutButton.classList.remove('hidden');
            logoutButtonMobile.classList.remove('hidden');
            profileLinkText.textContent = currentUser.email || '프로필';
            profileLinkTextMobile.textContent = currentUser.email || '프로필';
            if (currentUser.photoURL) userAvatar.src = currentUser.photoURL;
            else userAvatar.src = `https://placehold.co/40x40/7F00FF/FFFFFF?text=${(currentUser.email || 'U').charAt(0).toUpperCase()}`;

            if (isAdmin) {
                console.log("Admin user detected, applying admin UI.");
                document.body.classList.add('admin-logged-in');
            } else {
                console.log("Regular user detected, removing admin UI.");
                document.body.classList.remove('admin-logged-in');
            }
            updateProfileSection();
        }

        function updateUIAfterLogout() {
            if (!logoutButton || !logoutButtonMobile || !profileLinkText || !profileLinkTextMobile || !userAvatar) return;
            console.log("Updating UI for logged-out user.");
            logoutButton.classList.add('hidden');
            logoutButtonMobile.classList.add('hidden');
            profileLinkText.textContent = '프로필';
            profileLinkTextMobile.textContent = '프로필';
            userAvatar.src = "https://placehold.co/40x40/1A0933/E0E0E0?text=U";
            updateProfileSection();
        }
        
        function updateProfileSection() {
            const profileContent = document.getElementById('profileContent');
            const profileNotLoggedIn = document.getElementById('profileNotLoggedIn');
            if (!profileContent || !profileNotLoggedIn) return;

            if (currentUser) {
                profileContent.classList.remove('hidden');
                profileNotLoggedIn.classList.add('hidden');
                document.getElementById('profileUserAvatar').src = userAvatar.src;
                document.getElementById('profileUserName').textContent = currentUser.displayName || currentUser.email || '사용자';
                document.getElementById('profileUserEmail').textContent = currentUser.email;
                const creationTime = currentUser.metadata.creationTime ? new Date(currentUser.metadata.creationTime).toLocaleDateString() : 'N/A';
                document.getElementById('profileJoinDate').textContent = `가입일: ${creationTime}`;
                
                const adminStatusEl = document.getElementById('profileAdminStatus');
                if (adminStatusEl) { 
                    if (isAdmin) {
                        adminStatusEl.textContent = `관리자 여부: 예`;
                        adminStatusEl.style.display = 'inline-block'; 
                    } else {
                         adminStatusEl.style.display = 'none';
                    }
                }
            } else {
                profileContent.classList.add('hidden');
                profileNotLoggedIn.classList.remove('hidden');
            }
        }
        
        function clearUserSpecificDataAndUI() {
            userLikedItemsMap.clear();
            userPlaylists = [];
            userSubscribedArtistsSet.clear();
            if (myPlaylistsContainer && myPlaylistsPlaceholder) clearContainer(myPlaylistsContainer, myPlaylistsPlaceholder, "로그인이 필요합니다.");
            if (subscribedArtistsContainer && subscribedArtistsPlaceholder) clearContainer(subscribedArtistsContainer, subscribedArtistsPlaceholder, "로그인이 필요합니다.");
            if (likedSongsContainer && likedSongsPlaceholder) clearContainer(likedSongsContainer, likedSongsPlaceholder, "로그인이 필요합니다.");
        }

        // --- 콘텐츠 렌더링 함수 ---
        function createContentItemHTML(itemData, isChartItem = false) {
            let tagsHTML = itemData.tags ? itemData.tags.split(',').map(tag => `#${tag.trim()}`).join(' ') : '';
            if (itemData.genre) tagsHTML += ` <span class="text-purple-400">#${itemData.genre}</span>`;
            if (itemData.mood) tagsHTML += ` <span class="text-green-300">#${itemData.mood}</span>`;
            if (itemData.isInstrumental) tagsHTML += ` <span class="text-cyan-400">#Instrumental</span>`; 
            if (isChartItem) tagsHTML += ` <span class="text-yellow-300"><i class="fas fa-eye text-xs"></i> ${itemData.views || 0}</span>`;
            let actionButtonsHTML = `<div class="item-action-icon-wrapper">`;
            if (currentUser) { 
                actionButtonsHTML += `<i class="fas fa-list-ul item-action-icon add-to-playlist-icon" title="플레이리스트에 추가"></i>`;
                const isLiked = isItemLiked(itemData.itemId || itemData.id);
                const likeIconClass = isLiked ? 'fas fa-heart text-red-500' : 'far fa-heart';
                const likeTitle = isLiked ? '좋아요 취소' : '좋아요';
                actionButtonsHTML +=`<i class="${likeIconClass} item-action-icon like-item-button ${isLiked ? 'liked' : ''}" title="${likeTitle}"></i>`;
            }
            if (isAdmin) {
                if (itemData.isRecommended !== undefined) { 
                    let starIconClass = itemData.isRecommended ? 'fas fa-star' : 'far fa-star';
                    let starColorClass = itemData.isRecommended ? 'recommended' : '';
                    let recommendTitleText = itemData.isRecommended ? '추천 취소' : '추천 하기';
                    actionButtonsHTML +=`<i class="${starIconClass} item-action-icon recommend-checkbox-icon ${starColorClass}" title="${recommendTitleText}"></i>`;
                }
                actionButtonsHTML +=`<i class="fas fa-pencil-alt item-action-icon edit-item-button" title="콘텐츠 정보 수정"></i>`;
                actionButtonsHTML +=`<i class="fas fa-trash-alt item-action-icon delete-item-button" title="콘텐츠 삭제"></i>`;
            }
            actionButtonsHTML += `</div>`;
            const imageClass = "h-20 sm:h-24 md:h-32"; 
            const artistDisplay = itemData.aiMusicArtist || itemData.aiTool || 'N/A'; 
            let subscribeIconHTML = '';
            if (currentUser) { 
                const isSubscribedByCurrentUser = isArtistSubscribed(artistDisplay); 
                const subscribeIconClass = isSubscribedByCurrentUser ? 'fas fa-heart text-red-500 subscribed' : 'far fa-heart';
                const subscribeTitle = isSubscribedByCurrentUser ? `${artistDisplay} 구독 취소` : `${artistDisplay} 구독`;
                subscribeIconHTML = `<i class="${subscribeIconClass} subscribe-artist-icon" data-artist-name="${artistDisplay}" title="${subscribeTitle}"></i>`;
            }
            return `${actionButtonsHTML}<div class="thumbnail-image-container mb-1"><img src="${getYouTubeThumbnailUrl(itemData.youtubeId)}" alt="${itemData.title}" class="thumbnail-image ${imageClass}" onerror="this.onerror=null;this.src='${thumbnailErrorPlaceholder}';"></div><h4 class="item-title truncate">${itemData.title}</h4><div class="item-artist-wrapper"><p class="item-artist text-gray-400 truncate">${artistDisplay}</p>${subscribeIconHTML}</div><span class="item-tags neon-accent">${tagsHTML}</span>`;
        }
        
        function renderContentItem(itemData, container, isChartItem = false) {
            if (!container) return;
            const newItemDiv = document.createElement('div');
            let itemClasses = 'youtube-playable glassmorphism p-2 sm:p-3 rounded-lg hover:shadow-lg hover:shadow-purple-500/30 transition-shadow cursor-pointer'; 
            if (isChartItem && container.id === 'aionChartContainer' && window.innerWidth >= 640 ) { 
                 itemClasses += ' w-3/5 sm:w-auto flex-none'; 
            }
            newItemDiv.className = itemClasses;
            newItemDiv.dataset.youtubeId = itemData.youtubeId;
            newItemDiv.dataset.itemId = itemData.itemId || itemData.id;
            newItemDiv.innerHTML = createContentItemHTML(itemData, isChartItem); 
            if (!isChartItem && container === newUploadsContainer) {
                 container.insertBefore(newItemDiv, container.firstChild);
            } else {
                 container.appendChild(newItemDiv);
            }
        }
        
        function clearContainer(container, placeholderElement = null, message = "데이터가 없습니다.") { 
            if (!container) return;
            while (container.firstChild && container.firstChild !== placeholderElement) {
                container.removeChild(container.firstChild);
            }
             while (container.lastChild && container.lastChild !== placeholderElement) {
                container.removeChild(container.lastChild);
            }
            if (placeholderElement) {
                placeholderElement.textContent = message;
                placeholderElement.classList.remove('hidden');
                if (!container.contains(placeholderElement)) {
                    container.appendChild(placeholderElement);
                }
            }
        }
        
        function renderPageContent() {
            renderNewUploadsSection(allContentData);
            renderAionChart(allContentData);
            renderRecommendedMusicSection(allContentData);
            if (currentUser) { 
                renderMyPlaylists(); 
                renderSubscribedArtists(); 
                renderLikedSongs(); 
            } else { 
                clearUserSpecificDataAndUI();
            }
        }
        
        function renderNewUploadsSection(items) {
            if (!newUploadsContainer) return;
            clearContainer(newUploadsContainer, newUploadsPlaceholder, "새로운 콘텐츠가 없습니다.");
            const itemsToDisplay = [...items].sort((a,b) => (b.createdAt && a.createdAt && b.createdAt.toMillis && a.createdAt.toMillis) ? b.createdAt.toMillis() - a.createdAt.toMillis() : 0);
            if (itemsToDisplay.length > 0) {
                if(newUploadsPlaceholder) newUploadsPlaceholder.classList.add('hidden');
                itemsToDisplay.forEach(item => renderContentItem(item, newUploadsContainer, false));
            }
        }

        function renderRecommendedMusicSection(items) {
            if (!recommendedMusicContainer || !recommendedMusicPlaceholder) return;
            clearContainer(recommendedMusicContainer, recommendedMusicPlaceholder, "추천 음악이 없습니다.");
            const recommendedItems = items.filter(item => item.isRecommended === true);
            if (recommendedItems.length > 0) {
                if(recommendedMusicPlaceholder) recommendedMusicPlaceholder.classList.add('hidden');
                recommendedItems.forEach(item => renderContentItem(item, recommendedMusicContainer, false));
            }
        }
        
        function renderAionChart(items) {
            if (!aionChartContainer) return;
            clearContainer(aionChartContainer, aionChartPlaceholder, "차트에 표시할 콘텐츠가 없습니다.");
            const chartItemsData = items
                .filter(item => (item.views || 0) > 0) 
                .sort((a, b) => (b.views || 0) - (a.views || 0)) 
                .slice(0, 10); 
            if (chartItemsData.length > 0) {
                if(aionChartPlaceholder) aionChartPlaceholder.classList.add('hidden'); 
                chartItemsData.forEach(item => renderContentItem(item, aionChartContainer, true));
            }
        }
        
        // --- Firestore 데이터 로드 함수 ---
        async function loadUserSpecificDataFromFirestore() {
            if (!currentUser) {
                clearUserSpecificDataAndUI();
                return;
            }
            userLikedItemsMap.clear();
            userPlaylists = [];
            userSubscribedArtistsSet.clear();
            const uid = currentUser.uid;
            try {
                const likedItemsCollectionRef = collection(db, 'users', uid, 'likedItems');
                const playlistsCollectionRef = collection(db, 'users', uid, 'playlists');
                const subscribedArtistsCollectionRef = collection(db, 'users', uid, 'subscribedArtists');

                const [likedSnapshot, playlistsSnapshot, subsSnapshot] = await Promise.all([
                    getDocs(likedItemsCollectionRef),
                    getDocs(query(playlistsCollectionRef, orderBy('createdAt', 'desc'))),
                    getDocs(subscribedArtistsCollectionRef)
                ]);

                likedSnapshot.forEach(doc => userLikedItemsMap.set(doc.id, true));
                playlistsSnapshot.forEach(doc => userPlaylists.push({ id: doc.id, ...doc.data() }));
                subsSnapshot.forEach(doc => userSubscribedArtistsSet.add(doc.id));
                console.log("User specific data loaded. Liked:", userLikedItemsMap.size, "Playlists:", userPlaylists.length, "Subs:", userSubscribedArtistsSet.size);
            } catch (error) {
                console.error("Error loading user specific data:", error);
                showToast("사용자 데이터를 불러오는 중 오류가 발생했습니다.");
            }
        }

        function loadContentItemsFromFirestore() {
            if (contentListenerUnsubscribe) {
                contentListenerUnsubscribe(); 
                console.log("Previous content listener unsubscribed.");
            }
            const contentItemsQuery = query(collection(db, 'contentItems'), orderBy('createdAt', 'desc'));
            contentListenerUnsubscribe = onSnapshot(contentItemsQuery, (querySnapshot) => {
                const itemsFromFirestore = [];
                querySnapshot.forEach((doc) => {
                    itemsFromFirestore.push({ ...doc.data(), itemId: doc.data().itemId || doc.id, id: doc.id }); 
                });
                allContentData = itemsFromFirestore; 
                console.log("Content items loaded/updated from Firestore: ", allContentData.length);
                renderPageContent(); 
              }, (error) => {
                console.error("Error fetching contentItems from Firestore: ", error);
                showToast('콘텐츠를 불러오는데 실패했습니다 (Firestore 오류).');
                allContentData = []; 
                renderPageContent();
              });
        }

        // --- Firestore 기반 좋아요, 플레이리스트, 구독 기능 ---
        function isItemLiked(itemId) {
            if (!currentUser) return false;
            return userLikedItemsMap.has(itemId);
        }

        async function toggleLikeItem(itemId) {
            if (!currentUser || !itemId) return;
            const itemDocRef = doc(db, 'users', currentUser.uid, 'likedItems', itemId);
            const originalItem = allContentData.find(item => (item.itemId || item.id) === itemId);
            try {
                if (userLikedItemsMap.has(itemId)) {
                    await deleteDoc(itemDocRef);
                    userLikedItemsMap.delete(itemId);
                    showToast('좋아요를 취소했습니다.');
                } else {
                    await setDoc(itemDocRef, { 
                        likedAt: serverTimestamp(),
                        title: originalItem?.title || "Unknown Title", 
                        youtubeId: originalItem?.youtubeId || null,
                        aiMusicArtist: originalItem?.aiMusicArtist || null,
                        aiTool: originalItem?.aiTool || null
                    });
                    userLikedItemsMap.set(itemId, true);
                    showToast('좋아요 표시한 곡에 추가했습니다.');
                }
                const likedButton = document.querySelector(`.youtube-playable[data-item-id="${itemId}"] .like-item-button`);
                if (likedButton) {
                    const isLikedNow = userLikedItemsMap.has(itemId);
                    likedButton.classList.toggle('liked', isLikedNow);
                    likedButton.classList.toggle('fas', isLikedNow);
                    likedButton.classList.toggle('far', !isLikedNow);
                    likedButton.title = isLikedNow ? '좋아요 취소' : '좋아요';
                }
                renderLikedSongs(); 
            } catch (error) {
                console.error("Error toggling like in Firestore:", error);
                showToast("좋아요 처리 중 오류 발생: " + error.message);
            }
        }

        async function renderLikedSongs() {
            if (!likedSongsContainer || !likedSongsPlaceholder) return;
            if (!currentUser) { 
                clearContainer(likedSongsContainer, likedSongsPlaceholder, "로그인이 필요합니다.");
                return; 
            }
            clearContainer(likedSongsContainer, likedSongsPlaceholder, "좋아요 표시한 곡을 불러오는 중...");
            
            const likedItemDetails = [];
            for (const itemId of userLikedItemsMap.keys()) { 
                let itemData = allContentData.find(item => (item.itemId || item.id) === itemId);
                if (!itemData) { 
                    try {
                        const likedItemDocRef = doc(db, 'users', currentUser.uid, 'likedItems', itemId);
                        const docSnap = await getDoc(likedItemDocRef); 
                        if (docSnap.exists()) { 
                            itemData = { id: docSnap.id, ...docSnap.data(), isFromLikedCollection: true }; 
                        }
                    } catch (e) { console.error("Error fetching liked item detail from Firestore:", itemId, e); }
                }
                if (itemData && itemData.youtubeId) likedItemDetails.push(itemData); 
            }
             likedItemDetails.sort((a,b) => {
                const timeA = a.likedAt && a.likedAt.toMillis ? a.likedAt.toMillis() : 0;
                const timeB = b.likedAt && b.likedAt.toMillis ? b.likedAt.toMillis() : 0;
                return timeB - timeA;
            });

            if (likedItemDetails.length > 0) {
                if(likedSongsPlaceholder) likedSongsPlaceholder.classList.add('hidden');
                likedItemDetails.forEach(itemData => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'youtube-playable glassmorphism p-3 rounded-lg flex items-center justify-between hover:bg-purple-700/20 cursor-pointer';
                    itemDiv.dataset.youtubeId = itemData.youtubeId;
                    itemDiv.dataset.itemId = itemData.itemId || itemData.id;
                    const img = document.createElement('img');
                    img.src = getYouTubeThumbnailUrl(itemData.youtubeId);
                    img.alt = itemData.title || '제목 없음';
                    img.className = 'w-12 h-12 object-cover rounded-md mr-3';
                    img.onerror = function() { this.src = thumbnailErrorPlaceholder; };
                    const textInfoDiv = document.createElement('div');
                    textInfoDiv.className = 'flex-grow min-w-0';
                    const titleH5 = document.createElement('h5');
                    titleH5.className = 'item-title truncate';
                    titleH5.textContent = itemData.title || '제목 없음';
                    const artistP = document.createElement('p');
                    artistP.className = 'item-artist text-gray-400 truncate';
                    artistP.textContent = itemData.aiMusicArtist || itemData.aiTool || 'N/A';
                    textInfoDiv.appendChild(titleH5); textInfoDiv.appendChild(artistP);
                    const actionWrapper = document.createElement('div'); actionWrapper.className = 'flex items-center flex-shrink-0';
                    const playButton = document.createElement('button'); playButton.className = 'p-2 text-gray-300 hover:text-white'; playButton.innerHTML = '<i class="fas fa-play"></i>';
                    const unlikeButton = document.createElement('button'); unlikeButton.className = 'p-2 text-red-400 hover:text-red-600 ml-2 like-item-button'; 
                    unlikeButton.innerHTML = '<i class="fas fa-heart-broken"></i>'; unlikeButton.title = "좋아요 취소";
                    actionWrapper.appendChild(playButton); actionWrapper.appendChild(unlikeButton);
                    itemDiv.appendChild(img); itemDiv.appendChild(textInfoDiv); itemDiv.appendChild(actionWrapper);
                    likedSongsContainer.appendChild(itemDiv);
                });
            } else {
                clearContainer(likedSongsContainer, likedSongsPlaceholder, "아직 좋아요 표시한 곡이 없습니다.");
            }
        }

        function isArtistSubscribed(artistName) {
            if (!currentUser || !artistName || artistName === 'N/A') return false;
            return userSubscribedArtistsSet.has(artistName);
        }
        async function toggleArtistSubscription(artistName) {
            if (!currentUser) { showToast('로그인이 필요합니다.'); return; }
            if (!artistName || artistName === 'N/A') { showToast('유효한 아티스트 이름이 아닙니다.'); return; }
            const artistDocRef = doc(db, 'users', currentUser.uid, 'subscribedArtists', artistName); 
            try {
                if (userSubscribedArtistsSet.has(artistName)) {
                    await deleteDoc(artistDocRef); 
                    userSubscribedArtistsSet.delete(artistName);
                    showToast(`${artistName} 구독을 취소했습니다.`);
                } else {
                    await setDoc(artistDocRef, { subscribedAt: serverTimestamp() }); 
                    userSubscribedArtistsSet.add(artistName);
                    showToast(`${artistName}을(를) 구독했습니다.`);
                }
                const subscribeIcons = document.querySelectorAll(`.subscribe-artist-icon[data-artist-name="${artistName}"]`);
                subscribeIcons.forEach(icon => {
                    const isSub = userSubscribedArtistsSet.has(artistName);
                    icon.classList.toggle('subscribed', isSub);
                    icon.classList.toggle('fas', isSub); icon.classList.toggle('far', !isSub);
                    icon.title = isSub ? `${artistName} 구독 취소` : `${artistName} 구독`;
                });
                renderSubscribedArtists(); 
            } catch (error) { showToast("구독 처리 중 오류 발생: " + error.message); }
        }
        function renderSubscribedArtists() {
            if (!subscribedArtistsContainer || !subscribedArtistsPlaceholder) return;
            if (!currentUser) { clearContainer(subscribedArtistsContainer, subscribedArtistsPlaceholder, "로그인이 필요합니다."); return; }
            clearContainer(subscribedArtistsContainer, subscribedArtistsPlaceholder, "구독 아티스트 로딩 중...");
            if (userSubscribedArtistsSet.size > 0) {
                if(subscribedArtistsPlaceholder) subscribedArtistsPlaceholder.classList.add('hidden');
                userSubscribedArtistsSet.forEach(artistName => {
                    const div = document.createElement('div');
                    div.className = 'flex items-center justify-between p-2 glassmorphism rounded-md hover:bg-purple-700/20';
                    const nameSpan = document.createElement('span'); nameSpan.className = 'text-sm'; nameSpan.textContent = artistName;
                    const unsubscribeButton = document.createElement('button');
                    unsubscribeButton.className = 'text-xs text-red-400 hover:text-red-600 px-2 py-1 rounded hover:bg-red-700/20';
                    unsubscribeButton.textContent = '구독 취소';
                    unsubscribeButton.addEventListener('click', (e) => { e.stopPropagation(); toggleArtistSubscription(artistName); });
                    div.appendChild(nameSpan); div.appendChild(unsubscribeButton);
                    subscribedArtistsContainer.appendChild(div);
                });
            } else { clearContainer(subscribedArtistsContainer, subscribedArtistsPlaceholder, "아직 구독한 아티스트가 없습니다."); }
        }

        // --- 플레이리스트 함수들 ---
        if(createPlaylistButton) {
            createPlaylistButton.addEventListener('click', () => {
                if (!currentUser) { showToast('로그인이 필요합니다.'); return; }
                if(createPlaylistModal) createPlaylistModal.classList.remove('hidden');
                if(newPlaylistNameInput) newPlaylistNameInput.value = '';
            });
        }
        if(cancelCreatePlaylist && createPlaylistModal) cancelCreatePlaylist.addEventListener('click', () => createPlaylistModal.classList.add('hidden'));
        
        if(confirmCreatePlaylist && newPlaylistNameInput && createPlaylistModal) {
            confirmCreatePlaylist.addEventListener('click', async () => {
                if (!currentUser) { showToast('로그인이 필요합니다.'); return; }
                const playlistName = newPlaylistNameInput.value.trim();
                if (playlistName) {
                    try {
                        const playlistsCollectionRef = collection(db, 'users', currentUser.uid, 'playlists');
                        const newPlaylistRef = await addDoc(playlistsCollectionRef, { 
                            name: playlistName, items: [], createdAt: serverTimestamp()
                        });
                        userPlaylists.unshift({ id: newPlaylistRef.id, name: playlistName, items: [], createdAt: new Date() }); 
                        renderMyPlaylists();
                        createPlaylistModal.classList.add('hidden');
                        showToast(`플레이리스트 '${playlistName}'가 생성되었습니다.`);
                    } catch (error) { console.error("Error creating playlist:", error); showToast("플레이리스트 생성 중 오류 발생: " + error.message); }
                } else { showToast('플레이리스트 이름을 입력해주세요.'); }
            });
        }

        function openAddToPlaylistModal() {
            if (!currentUser) { showToast('로그인이 필요합니다.'); return; }
            if (!addToPlaylistModal || !playlistSelectionContainer || !playlistSelectionPlaceholder) return;
            playlistSelectionContainer.innerHTML = ''; 
            if (userPlaylists.length > 0) { 
                if (playlistSelectionPlaceholder) playlistSelectionPlaceholder.classList.add('hidden');
                userPlaylists.forEach(pl => { 
                    const div = document.createElement('div');
                    div.className = 'flex items-center space-x-2 p-2 hover:bg-purple-700/30 rounded-md cursor-pointer';
                    div.dataset.playlistId = pl.id;
                    const input = document.createElement('input'); input.type = 'radio'; input.name = 'playlistSelection'; input.value = pl.id;
                    input.className = 'form-radio h-4 w-4 text-purple-600 bg-gray-700 border-gray-600 focus:ring-purple-500';
                    const label = document.createElement('label'); label.htmlFor = `pl-select-${pl.id}`; label.textContent = pl.name; label.className = 'text-sm';
                    input.id = `pl-select-${pl.id}`;
                    div.appendChild(input); div.appendChild(label);
                    label.addEventListener('click', (e) => { e.stopPropagation(); input.checked = true; });
                    div.addEventListener('click', () => { input.checked = true; });
                    playlistSelectionContainer.appendChild(div);
                });
            } else {
                if (playlistSelectionPlaceholder && !playlistSelectionContainer.contains(playlistSelectionPlaceholder)) {
                     playlistSelectionContainer.appendChild(playlistSelectionPlaceholder);
                }
                if (playlistSelectionPlaceholder) {
                    playlistSelectionPlaceholder.textContent = "플레이리스트가 없습니다. 먼저 만들어주세요.";
                    playlistSelectionPlaceholder.classList.remove('hidden');
                }
            }
            if(newPlaylistNameInAddModalInput) newPlaylistNameInAddModalInput.value = '';
            if(addToPlaylistModal) addToPlaylistModal.classList.remove('hidden');
        }

        if(cancelAddToPlaylist && addToPlaylistModal) cancelAddToPlaylist.addEventListener('click', () => { addToPlaylistModal.classList.add('hidden'); currentItemToAddToPlaylist = null; });

        if(confirmAddToPlaylist && newPlaylistNameInAddModalInput && addToPlaylistModal) {
            confirmAddToPlaylist.addEventListener('click', async () => {
                if (!currentUser || !currentItemToAddToPlaylist) return;
                const selectedRadio = playlistSelectionContainer.querySelector('input[name="playlistSelection"]:checked');
                const newPlaylistName = newPlaylistNameInAddModalInput.value.trim();
                let targetPlaylistId = null; let targetPlaylistName = '';
                try {
                    if (newPlaylistName) { 
                        const playlistsCollectionRef = collection(db, 'users', currentUser.uid, 'playlists');
                        const newPlaylistRef = await addDoc(playlistsCollectionRef, { 
                            name: newPlaylistName, items: [currentItemToAddToPlaylist], createdAt: serverTimestamp()
                        });
                        targetPlaylistId = newPlaylistRef.id; targetPlaylistName = newPlaylistName;
                        userPlaylists.unshift({ id: targetPlaylistId, name: targetPlaylistName, items: [currentItemToAddToPlaylist], createdAt: new Date() });
                        showToast(`'${targetPlaylistName}' 플레이리스트에 곡을 추가했습니다.`);
                    } else if (selectedRadio) { 
                        targetPlaylistId = selectedRadio.value;
                        const playlistDocRef = doc(db, 'users', currentUser.uid, 'playlists', targetPlaylistId);
                        await updateDoc(playlistDocRef, { items: arrayUnion(currentItemToAddToPlaylist) }); 
                        const playlist = userPlaylists.find(p => p.id === targetPlaylistId);
                        if (playlist) {
                            targetPlaylistName = playlist.name;
                            if (!playlist.items.includes(currentItemToAddToPlaylist)) playlist.items.push(currentItemToAddToPlaylist);
                        }
                        showToast(`'${targetPlaylistName}' 플레이리스트에 곡을 추가했습니다.`);
                    } else { showToast('플레이리스트를 선택하거나 새 플레이리스트 이름을 입력해주세요.'); return; }
                    renderMyPlaylists(); 
                    addToPlaylistModal.classList.add('hidden');
                    currentItemToAddToPlaylist = null;
                } catch (error) { showToast("플레이리스트 추가 중 오류 발생: " + error.message); }
            });
        }
        
        function renderMyPlaylists() {
            if (!myPlaylistsContainer || !myPlaylistsPlaceholder) return;
            if (!currentUser) { clearContainer(myPlaylistsContainer, myPlaylistsPlaceholder, "로그인이 필요합니다."); return; }
            clearContainer(myPlaylistsContainer, myPlaylistsPlaceholder, "플레이리스트 로딩 중...");
            if (userPlaylists.length > 0) {
                if(myPlaylistsPlaceholder) myPlaylistsPlaceholder.classList.add('hidden');
                userPlaylists.forEach(pl => {
                    const card = document.createElement('div');
                    card.className = 'playlist-card glassmorphism cursor-pointer'; card.dataset.playlistId = pl.id;
                    const cover = document.createElement('div'); cover.className = 'playlist-cover';
                    if (pl.items && pl.items.length > 0) {
                        const firstItemId = pl.items[0];
                        const firstItemData = allContentData.find(item => (item.itemId || item.id) === firstItemId);
                        if (firstItemData && firstItemData.youtubeId) {
                            const img = document.createElement('img');
                            img.src = getYouTubeThumbnailUrl(firstItemData.youtubeId);
                            img.alt = pl.name; img.className = 'w-full h-full object-cover rounded-md';
                            img.onerror = function() { this.parentElement.innerHTML = '<i class="fas fa-music"></i>'; }; 
                            cover.appendChild(img);
                        } else { cover.innerHTML = '<i class="fas fa-music"></i>'; }
                    } else { cover.innerHTML = '<i class="fas fa-music"></i>'; }
                    const info = document.createElement('div');
                    const name = document.createElement('h4'); name.className = 'font-semibold text-sm'; name.textContent = pl.name;
                    const count = document.createElement('p'); count.className = 'text-xs text-gray-400'; count.textContent = `${pl.items ? pl.items.length : 0}곡`;
                    info.appendChild(name); info.appendChild(count);
                    card.appendChild(cover); card.appendChild(info);
                    card.addEventListener('click', () => openPlaylistDetailModal(pl.id));
                    myPlaylistsContainer.appendChild(card);
                });
            } else { clearContainer(myPlaylistsContainer, myPlaylistsPlaceholder, "만든 플레이리스트가 없습니다."); }
        }

        async function openPlaylistDetailModal(playlistId) {
            if (!currentUser) { showToast('로그인이 필요합니다.'); return; }
            currentViewingPlaylistId = playlistId;
            const playlist = userPlaylists.find(p => p.id === playlistId);
            if (!playlist || !playlistDetailModal || !playlistDetailNameElement || !playlistDetailItemsContainer || !playlistDetailPlaceholder) return;
            playlistDetailNameElement.textContent = playlist.name;
            clearContainer(playlistDetailItemsContainer, playlistDetailPlaceholder, "플레이리스트 곡 로딩 중...");
            if (playlist.items && playlist.items.length > 0) {
                if(playlistDetailPlaceholder) playlistDetailPlaceholder.classList.add('hidden');
                playlist.items.forEach(itemId => {
                    const itemData = allContentData.find(item => (item.itemId || item.id) === itemId);
                    if (itemData) {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'youtube-playable glassmorphism p-3 rounded-lg flex items-center justify-between hover:bg-purple-700/20';
                        itemDiv.dataset.youtubeId = itemData.youtubeId; itemDiv.dataset.itemId = itemData.itemId || itemData.id;
                        const img = document.createElement('img');
                        img.src = getYouTubeThumbnailUrl(itemData.youtubeId); img.alt = itemData.title;
                        img.className = 'w-12 h-12 object-cover rounded-md mr-3';
                        img.onerror = function() { this.src = thumbnailErrorPlaceholder; };
                        const textInfoDiv = document.createElement('div'); textInfoDiv.className = 'flex-grow min-w-0';
                        const titleH5 = document.createElement('h5'); titleH5.className = 'item-title truncate'; titleH5.textContent = itemData.title;
                        const artistP = document.createElement('p'); artistP.className = 'item-artist text-gray-400 truncate'; artistP.textContent = itemData.aiMusicArtist || itemData.aiTool || 'N/A';
                        textInfoDiv.appendChild(titleH5); textInfoDiv.appendChild(artistP);
                        const actionWrapper = document.createElement('div'); actionWrapper.className = 'flex items-center flex-shrink-0';
                        const playButton = document.createElement('button'); playButton.className = 'p-2 text-gray-300 hover:text-white'; playButton.innerHTML = '<i class="fas fa-play"></i>';
                        const removeButton = document.createElement('button'); removeButton.className = 'p-2 text-red-400 hover:text-red-600 ml-2'; removeButton.innerHTML = '<i class="fas fa-times"></i>'; removeButton.title = "플레이리스트에서 삭제";
                        removeButton.addEventListener('click', (e) => { e.stopPropagation(); removeSongFromPlaylist(playlistId, itemData.itemId || itemData.id); });
                        actionWrapper.appendChild(playButton); actionWrapper.appendChild(removeButton);
                        itemDiv.appendChild(img); itemDiv.appendChild(textInfoDiv); itemDiv.appendChild(actionWrapper);
                        playlistDetailItemsContainer.appendChild(itemDiv);
                    }
                });
            } else { clearContainer(playlistDetailItemsContainer, playlistDetailPlaceholder, "이 플레이리스트에 곡이 없습니다."); }
            if(playlistDetailModal) playlistDetailModal.classList.remove('hidden');
        }
        
        if(closePlaylistDetailModalButton && playlistDetailModal) closePlaylistDetailModalButton.addEventListener('click', () => { playlistDetailModal.classList.add('hidden'); currentViewingPlaylistId = null; });

        if(deletePlaylistButton && playlistDetailModal) {
            deletePlaylistButton.addEventListener('click', async () => {
                if (!currentUser || !currentViewingPlaylistId) return;
                if (confirm("이 플레이리스트를 정말 삭제하시겠습니까?")) {
                    try {
                        const playlistDocRef = doc(db, 'users', currentUser.uid, 'playlists', currentViewingPlaylistId);
                        await deleteDoc(playlistDocRef); 
                        userPlaylists = userPlaylists.filter(pl => pl.id !== currentViewingPlaylistId); 
                        renderMyPlaylists();
                        playlistDetailModal.classList.add('hidden');
                        showToast('플레이리스트가 삭제되었습니다.');
                        currentViewingPlaylistId = null;
                    } catch (error) { showToast("플레이리스트 삭제 중 오류 발생: " + error.message); }
                }
            });
        }

        async function removeSongFromPlaylist(playlistId, itemIdToRemove) {
            if (!currentUser) return;
            try {
                const playlistDocRef = doc(db, 'users', currentUser.uid, 'playlists', playlistId);
                await updateDoc(playlistDocRef, { items: arrayRemove(itemIdToRemove) }); 
                const playlist = userPlaylists.find(pl => pl.id === playlistId);
                if (playlist) playlist.items = playlist.items.filter(id => id !== itemIdToRemove); 
                openPlaylistDetailModal(playlistId); 
                renderMyPlaylists(); 
                showToast('플레이리스트에서 곡이 삭제되었습니다.');
            } catch (error) { showToast("곡 삭제 중 오류 발생: " + error.message); }
        }

        // --- 업로드 폼 필드 토글 ---
        if (uploadContentTypeSelect) {
            uploadContentTypeSelect.addEventListener('change', toggleUploadFields);
            toggleUploadFields(); 
        }
        function toggleUploadFields() {
             if (!uploadContentTypeSelect || !youtubeLinkGroup) return;
            if (uploadContentTypeSelect.value === 'mv') {
                youtubeLinkGroup.classList.remove('hidden');
            } else {
                 youtubeLinkGroup.classList.add('hidden');
            }
        }
        
        // --- JSON 내보내기 기능 ---
        if (exportBtnSidebar) exportBtnSidebar.addEventListener('click', exportContentToJson);
        if (exportBtnMobileSidebar) exportBtnMobileSidebar.addEventListener('click', exportContentToJson);
        function exportContentToJson() {
            if (!isAdmin) { showToast("관리자만 내보낼 수 있습니다."); return; }
            if (allContentData.length === 0) { showToast('내보낼 콘텐츠가 없습니다.'); return; }
            const exportData = allContentData.map(item => ({
                itemId: item.itemId || item.id, youtubeId: item.youtubeId, title: item.title,
                aiMusicArtist: item.aiMusicArtist, aiTool: item.aiTool, isInstrumental: item.isInstrumental,
                genre: item.genre, mood: item.mood, tags: item.tags, views: item.views || 0, 
                isRecommended: item.isRecommended || false,
                createdAt: item.createdAt && item.createdAt.toDate ? item.createdAt.toDate().toISOString() : null,
                updatedAt: item.updatedAt && item.updatedAt.toDate ? item.updatedAt.toDate().toISOString() : null,
                uploaderUid: item.uploaderUid || null, uploaderEmail: item.uploaderEmail || null
            }));
            const jsonString = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'aion_content_firestore.json'; 
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            showToast('콘텐츠가 aion_content_firestore.json 파일로 내보내졌습니다.');
        }
        
        // --- 인증 관련 함수 ---
        onAuthStateChanged(authInstance, async (user) => { 
            console.log("[AUTH STATE CHANGED] User object:", user ? user.uid : "No user");
            if (user) {
                if (loginFormContainer) {
                    loginFormContainer.classList.add('hidden');
                    console.log("[AUTH STATE CHANGED] Login form hidden.");
                }
                currentUser = user;
                document.body.classList.add('user-logged-in');
                try {
                    const idTokenResult = await currentUser.getIdTokenResult(true); 
                    isAdmin = idTokenResult.claims.admin === true;
                    console.log("[AUTH STATE CHANGED] isAdmin determined:", isAdmin, "Claims:", idTokenResult.claims);
                } catch (error) {
                    console.error("[AUTH STATE CHANGED] Error getting ID token result:", error);
                    isAdmin = false;
                }
                updateUIAfterLogin(); 
                await loadUserSpecificDataFromFirestore(); 
                loadContentItemsFromFirestore(); 
            } else {
                currentUser = null;
                isAdmin = false;
                if (loginFormContainer) {
                    loginFormContainer.classList.remove('hidden');
                    console.log("[AUTH STATE CHANGED] User signed out or not logged in. Login form shown.");
                }
                document.body.classList.remove('user-logged-in');
                document.body.classList.remove('admin-logged-in'); 
                updateUIAfterLogout();
                clearUserSpecificDataAndUI();
                loadContentItemsFromFirestore(); 
            }
        });

        // --- 페이지 초기화 ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded event fired.");
            // 초기 홈 섹션 활성화
            const homeNavItemDesktop = desktopSidebar.querySelector('.nav-item[data-section="home"]');
            const homeNavItemMobile = mobileSidebar.querySelector('.nav-item[data-section="home"]');
            if (homeNavItemDesktop) {
                homeNavItemDesktop.classList.add(activeNavClass);
                homeNavItemDesktop.classList.remove(inactiveNavClass);
            }
            if (homeNavItemMobile) {
                homeNavItemMobile.classList.add(activeNavClass);
                homeNavItemMobile.classList.remove(inactiveNavClass);
            }
            if(document.getElementById('home')) {
                document.getElementById('home').classList.add('active');
            }

            // 네비게이션 아이템 이벤트 리스너 설정
            document.querySelectorAll('#desktopSidebar .nav-item, #mobileSidebar .nav-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.preventDefault();
                    const sectionId = item.dataset.section;
                    if (sectionId) {
                        switchSection(sectionId);
                        if (mobileSidebar && !mobileSidebar.classList.contains('-translate-x-full')) {
                            closeMobileSidebar(); 
                        }
                    }
                });
            });
            if (mobileMenuButton) mobileMenuButton.addEventListener('click', openMobileSidebar);
            if (closeMobileSidebarButton) closeMobileSidebarButton.addEventListener('click', closeMobileSidebar);
            if (mobileSidebarOverlay) mobileSidebarOverlay.addEventListener('click', closeMobileSidebar);

            // 로그인 폼 제출 이벤트 리스너
            if (loginForm) {
                loginForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    if (loginProcessing) { 
                        console.log("Login already in progress, ignoring duplicate submit.");
                        return;
                    }
                    loginProcessing = true;
                    if(loginSubmitButton) loginSubmitButton.disabled = true; 

                    const email = loginForm.loginEmail.value;
                    const password = loginForm.loginPassword.value;
                    if (loginErrorText) loginErrorText.textContent = '';
                    try {
                        console.log("Attempting login with email:", email);
                        await signInWithEmailAndPassword(authInstance, email, password); 
                        console.log("Login attempt successful for:", email); 
                    } catch (error) {
                        console.error("Login failed:", error);
                        if (loginErrorText) loginErrorText.textContent = "로그인 실패: " + error.message;
                        showToast("로그인 실패: " + error.message);
                    } finally {
                        loginProcessing = false; 
                        if(loginSubmitButton) loginSubmitButton.disabled = false; 
                    }
                });
            }

            // 로그아웃 버튼 이벤트 리스너
            async function handleLogout() { 
                try {
                    await signOut(authInstance); 
                    console.log("Logout successful.");
                } catch (error) {
                    console.error("Logout failed:", error);
                    showToast("로그아웃 실패: " + error.message);
                }
            }
            if (logoutButton) logoutButton.addEventListener('click', handleLogout);
            if (logoutButtonMobile) logoutButtonMobile.addEventListener('click', handleLogout);

            // 페이지 로드 시 로그인 폼을 기본적으로 표시합니다.
            if(loginFormContainer) { 
                 loginFormContainer.classList.remove('hidden'); 
                 console.log("DOMContentLoaded: Login form explicitly made visible initially.");
            }
        });

        /* Firestore 보안 규칙 및 Custom Claims 설정 알림은 이전과 동일 */
    </script>
</body>
</html>
